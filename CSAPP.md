# CSAPP

## 第一章:计算机系统漫游

计算机系统是由硬件和软件组成。所有计算机系统都有相似的硬件和软件组件， 它们又执行着相似的功能。

```c
#include<stdio.h>

int main()
{
	printf("hello,world\n");
	return 0;
}
```

跟踪hello程序的生命周期来开始对系统的学习

### 1.1信息就是位+上下文

源程序实际上就是一个由值0和1组成的位（又称为比特）序列， 8 个位被组织成一组， 称为字节。

大部分的现代计算机系统都使用ASCII标准来表示文本字符， 这种方式实际上就是用一个唯一的单字节大小的整数值气 来表示每个字符。

![](C:%5CUsers%5C19361%5CPictures%5CScreenshots%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20153252.png)

像 hello.c这样只由 ASCII字符构成的文件称为文本文件， 所有其他文件都称为二进制文件。

hello.c的表示方法说明了一个基本思想：系统中所有的信息包括磁盘文件、 内存中的程序、 内存中存放的用户数据以及网络上传送的数据， 都是由一串比特表示的。 区分不同数据对象的唯一方法是我们读到这些数据对象时的上下文。 比如， 在不同的上下文中，一个同样的字节序列可能表示一个整数、 浮点数、 字符串或者机器指令。

### 1.2程序被其他程序翻译成不同的格式

在Unix系统上， 从源文件到目标文件的转化是由编译器驱动程序完成的：linux> gee  -o hello hello.e 

![](C:%5CUsers%5C19361%5CPictures%5CScreenshots%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20154018.png)

- 处理阶段。预处理器(cpp)根据以字符＃开头的命令， 修改原始的C程序。 比如hello.c中第1行的五nclude <stdio. h> 命令告诉预处理器读取系统头文件stdio.h的内容， 并把它直接插入程序文本中。 结果就得到了另一个C程序， 通常是以．l作为文件扩展名。

- 编译阶段。 编译器(eel)将文本文件hello.i翻译成文本文件hello.s, 它包含一个汇编语言程序。 该程序包含函数main的定义， 如下所示：

  ```c
  main: 
    subq $8,  %rsp 
    movl $.LCO,  %edi 
    call puts 
    movl $0,  %eax 
    addq $8,  %rsp 
    ret
  ```

  定义中2~7行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的， 因为它为不同高级语言的不同编译器提供了通用的输出语言。 例如， C编译器和Fortran编译器产生的输出文件用的都是一样的汇编语言。

- 汇编阶段。 接下来， 汇编器(as)将hello.s翻译成机器语言指令， 把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式， 并将结果保存在目标文件hello.o中。 hello.o文件是一个**二进制文件**， 它包含的17个字节是函数main的指令编码。 如果我们在文本编辑器中打开 he llo.o文件， 将看到一堆乱码。

- 链接阶段。请注意， he荨o程序调用了 printf 函数， 它是每个C 编译器都提供的标准C库中的一个函数。printf 函数存在于一个名为 printf.o的单独的预编译好了的目标文件中， 而这个文件必须以某种方式合并到我们的 he荨o.o程序中。 链接器(Id)就负责处理这种合并。 结果就得到hello文件， 它是一个可执行目标文件（或者简称为可执行文件），可以被加载到内存中， 由系统执行。

### 1.3了解编译系统如何工作的益处

#### 1.3.1优化程序性能

 为了在 C程序中做出好的编码选择， 我们确实需要了解一些机器代码以及编译器将不同的C语旬转化为机器代码的方式。 

#### 1.3.2理解链接时出现的错误

根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。

#### 1.3.3避免安全漏洞

多年来， 缓冲区溢出错误是造成大多数网络和Internet服务器上安全漏洞的主要原因。

### 1.4处理器读并解释储存在内存中的指令

```shell
linux> ./hello 
hello,world 
linux> 
```

shell是一个命令行解释器， 它输出一个提示符，等待输入一个命令行， 然后执行这个命令。 如果该命令行的第一个单词不是一个内置的shell命令， 那么shell就会假设这是一个可执行文件的名字， 它将加载并运行这个文件。 所以在此例中， shell将加载并运行hello程序， 然后等待程序终止。hello程序在屏幕上输出它的消息，然后终止。shell随后输出一个提示符， 等待下一个输入的命令行。

#### 1.4.1系统硬件的组成

为了理解运行hello程序时发生了什么，我们需要了解一个典型系统的硬件组织

##### 1.总线

贯穿整个系统的是一组电子管道， 称作总线， 它携带信息字节并负责在各个部件间传递。 **通常总线被设计成传送定长的字节块，也就是字(word)。字中的字节数（即字长）是一个基本的系统参数， 各个系统中都不尽相同。 现在的大多数机器字长要么是4个字节(32位）， 要么是8个字节(64位）。** 本书中， 我们不对字长做任何固定的假设。 相反， 我们将在需要明确定义的上下文中具体说明一个”字”是多大。

##### 2.I/O设备

I/0（输入／输出）设备是系统与外部世界的联系通道。 我们的示例系统包括四个I/0设备： **作为用户输入的键盘和鼠标， 作为用户输出的显示器， 以及用千长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。**最开始， 可执行程序hello就存放在磁盘上。

每个I/0设备都通过一个控制器或适配器与I/0总线相连。 控制器和适配器之间的区别主要在千它们的封装方式。 控制器是 I/0设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。 而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在1/0总线和1/0设备之间传递信息。

![](C:%5CUsers%5C19361%5CPictures%5CScreenshots%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20164300.png)

##### 3.主存

主存是一个临时存储设备， 在处理器执行程序时， 用来存放程序和程序处理的数据。 **从物理上来说， 主存是由一组动态随机存取存储器(DRAM)芯片组成的。 从逻辑上来说， 存储器是一个线性的字节数组， 每个字节都有其唯一的地址（数组索引）， 这些地址是从零开始的。** 一般来说， 组成程序的每条机器指令都由不同数量的字节构成。与C程序变量相对应的数据项的大小是根据类型变化的。 比如， 在运行Linux的 x86-64机器上， short类型的数据需要2 个字节，int和 float类型需要4个字节， 而long和double类型需要8个字节。

##### 4.处理器

中央处理单元(CPU)，简称处理器， 是解释（或执行）**存储在主存中指令的引擎。 处理器的核心是一个大小为一个字的存储设备（或寄存器）， 称为程序计数器(PC)。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。**

从系统通电开始， 直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。 处理器看上去是按照一个非常简单的指令执行模型来操作的， 这个模型是由指令集架构决定的。 在这个模型中， 指令按照严格的顺序执行， 而执行一条指令包含执行一系列的步骤。**处理器从程序计数器指向的内存处读取指令， 解释指令中的位， 执行该指令指示的简单操作， 然后更新 PC, 使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。**

这样的简单操作并不多，它们围绕着主存、寄存器文件(registerfile)和算术／逻辑单元(ALU)进行。 寄存器文件是一个小的存储设备， 由一些单个字长的寄存器组成， 每个寄存器都有唯一的名字。ALU计算新的数据和地址值。 下面是一些简单操作的例子，CPU在指令的要求下可能会执行这些操作。

- 加载：从主存复制一个字节或者一个字到寄存器， 以覆盖寄存器原来的内容。
- 存储： 从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
- 操作： 把两个寄存器的内容复制到ALU, ALU对这两个字做算术运算， 并将结果存放到一个寄存器中， 以覆盖该寄存器中原来的内容。
- 跳转:从指令本身中抽取一个字，将这些字复制到程序计数器(PC)中， 以覆盖PC 中原来的值。

 指令集架构描述的是每条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。

#### 1.4.2运行hello程序

初始时，shell程序执行它的指令， 等待我们输入一个命令。 当我们在键盘上输入字符串"./hello" 后， shell程序将字符逐一读入寄存器， 再把它存放到内存中， 如图1-5 所示。

![](C:%5CUsers%5C19361%5CPictures%5CScreenshots%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20171003.png)

当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输入。 然后shell执行一系列指令来加载可执行的 hello文件， 这些指令将 hello 目标文件中的代码和数据从磁盘复制到主存。 数据包括最终会被输出的字符串“hello, world\n”。

利用直接存储器存取CDMA, 将在第 6 章中讨论）技术， 数据可以不通过处理器而直接从磁盘到达主存。 这个步骤如图1-6 所示。

![](C:%5CUsers%5C19361%5CPictures%5CScreenshots%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20171531.png)

一旦目标文件hello中的代码和数据被加载到主存，处理器就开始执行 hello程序的main程序中的机器语言指令。 这些指令将“hello, world\n"字符串中的字节从主存复制到寄存器文件， 再从寄存器文件中复制到显示设备， 最终显示在屏幕上。 这个步骤如图1-7所示。

![](C:%5CUsers%5C19361%5CPictures%5CScreenshots%5C%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-07-06%20171735.png)

### 1.5高速缓存至关重要





